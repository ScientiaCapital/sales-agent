{
  "skill_id": "crm_sync",
  "version": "1.0.0",
  "description": "Create CRM sync operation with 87% token reduction",
  "token_cost": 2000,
  "decision_tree": {
    "question": "What type of CRM sync do you need?",
    "options": {
      "close_crm_bidirectional": {
        "description": "Close CRM bidirectional sync",
        "template": "crm_sync.py.jinja2",
        "file_path": "backend/app/services/crm/{{ platform }}_sync.py",
        "extension": ".py"
      },
      "apollo_import": {
        "description": "Apollo.io import enrichment",
        "template": "crm_import.py.jinja2",
        "file_path": "backend/app/services/crm/{{ platform }}_sync.py",
        "extension": ".py"
      },
      "linkedin_import": {
        "description": "LinkedIn profile import",
        "template": "crm_import.py.jinja2",
        "file_path": "backend/app/services/crm/{{ platform }}_sync.py",
        "extension": ".py"
      }
    }
  },
  "prerequisites": {
    "files_exist": [
      "backend/app/services/crm/",
      "backend/app/models/crm.py"
    ],
    "env_vars": [
      "CLOSE_API_KEY",
      "APOLLO_API_KEY",
      "LINKEDIN_CLIENT_ID",
      "REDIS_URL"
    ]
  },
  "code_templates": {
    "close_crm_bidirectional": "import asyncio\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nimport redis.asyncio as redis\nfrom sqlalchemy.orm import Session\n\nfrom app.models.crm import CRMContact, CRMSyncLog\nfrom app.services.crm.close import CloseCRM\nfrom app.services.circuit_breaker import CircuitBreaker\nfrom app.services.retry_handler import retry_with_exponential_backoff\n\nclass {{ PlatformName }}SyncService:\n    \"\"\"{{ platform }} CRM sync service.\"\"\"\n    \n    def __init__(self, db: Session, redis_client: redis.Redis):\n        self.db = db\n        self.redis_client = redis_client\n        self.crm = CloseCRM()\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=5,\n            recovery_timeout=60,\n            expected_exception=Exception\n        )\n    \n    @retry_with_exponential_backoff(max_retries=3, base_delay=2.0)\n    async def sync_contacts(\n        self,\n        direction: str = \"bidirectional\",\n        filters: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Sync contacts with {{ platform }} CRM.\"\"\"\n        sync_log = CRMSyncLog(\n            platform=\"{{ platform }}\",\n            operation=\"sync_contacts\",\n            started_at=datetime.utcnow(),\n            status=\"running\"\n        )\n        self.db.add(sync_log)\n        self.db.commit()\n        \n        try:\n            if direction in [\"import\", \"bidirectional\"]:\n                await self._import_contacts(filters)\n            \n            if direction in [\"export\", \"bidirectional\"]:\n                await self._export_contacts(filters)\n            \n            # Update sync log\n            sync_log.status = \"completed\"\n            sync_log.completed_at = datetime.utcnow()\n            sync_log.duration_seconds = (sync_log.completed_at - sync_log.started_at).total_seconds()\n            \n            self.db.commit()\n            \n            return {\n                \"status\": \"success\",\n                \"platform\": \"{{ platform }}\",\n                \"direction\": direction,\n                \"duration_seconds\": sync_log.duration_seconds\n            }\n            \n        except Exception as e:\n            sync_log.status = \"failed\"\n            sync_log.error_message = str(e)\n            sync_log.completed_at = datetime.utcnow()\n            self.db.commit()\n            \n            raise\n    \n    async def _import_contacts(self, filters: Optional[Dict[str, Any]] = None):\n        \"\"\"Import contacts from {{ platform }} CRM.\"\"\"\n        # Get contacts from CRM\n        crm_contacts = await self.circuit_breaker.call(\n            self.crm.get_contacts,\n            filters or {}\n        )\n        \n        contacts_processed = 0\n        contacts_created = 0\n        contacts_updated = 0\n        \n        for crm_contact in crm_contacts:\n            contacts_processed += 1\n            \n            # Check if contact exists locally\n            existing_contact = self.db.query(CRMContact).filter(\n                CRMContact.crm_platform == \"{{ platform }}\",\n                CRMContact.external_id == crm_contact[\"id\"]\n            ).first()\n            \n            if existing_contact:\n                # Update existing contact\n                await self._update_contact(existing_contact, crm_contact)\n                contacts_updated += 1\n            else:\n                # Create new contact\n                await self._create_contact(crm_contact)\n                contacts_created += 1\n        \n        return {\n            \"contacts_processed\": contacts_processed,\n            \"contacts_created\": contacts_created,\n            \"contacts_updated\": contacts_updated\n        }\n    \n    async def _export_contacts(self, filters: Optional[Dict[str, Any]] = None):\n        \"\"\"Export contacts to {{ platform }} CRM.\"\"\"\n        # Get local contacts to export\n        local_contacts = self.db.query(CRMContact).filter(\n            CRMContact.crm_platform == \"{{ platform }}\",\n            CRMContact.last_synced_at.is_(None)  # Not yet synced\n        ).all()\n        \n        contacts_exported = 0\n        \n        for contact in local_contacts:\n            try:\n                # Export to CRM\n                await self.circuit_breaker.call(\n                    self.crm.create_contact,\n                    {\n                        \"name\": f\"{contact.first_name} {contact.last_name}\",\n                        \"email\": contact.email,\n                        \"phone\": contact.phone,\n                        \"company\": contact.company\n                    }\n                )\n                \n                # Update sync timestamp\n                contact.last_synced_at = datetime.utcnow()\n                contacts_exported += 1\n                \n            except Exception as e:\n                print(f\"Failed to export contact {contact.id}: {e}\")\n        \n        self.db.commit()\n        \n        return {\n            \"contacts_exported\": contacts_exported\n        }\n    \n    async def _create_contact(self, crm_contact: Dict[str, Any]):\n        \"\"\"Create new contact from CRM data.\"\"\"\n        contact = CRMContact(\n            crm_platform=\"{{ platform }}\",\n            external_id=crm_contact[\"id\"],\n            email=crm_contact.get(\"email\"),\n            first_name=crm_contact.get(\"first_name\"),\n            last_name=crm_contact.get(\"last_name\"),\n            company=crm_contact.get(\"company\"),\n            title=crm_contact.get(\"title\"),\n            phone=crm_contact.get(\"phone\"),\n            linkedin_url=crm_contact.get(\"linkedin_url\"),\n            enrichment_data=crm_contact.get(\"enrichment_data\", {}),\n            last_synced_at=datetime.utcnow()\n        )\n        \n        self.db.add(contact)\n        self.db.commit()\n    \n    async def _update_contact(self, existing_contact: CRMContact, crm_contact: Dict[str, Any]):\n        \"\"\"Update existing contact with CRM data.\"\"\"\n        # Resolve conflicts using last-write-wins\n        crm_updated = datetime.fromisoformat(crm_contact.get(\"updated_at\", \"1970-01-01T00:00:00\"))\n        \n        if crm_updated > existing_contact.last_synced_at:\n            # CRM data is newer, update local contact\n            existing_contact.email = crm_contact.get(\"email\") or existing_contact.email\n            existing_contact.first_name = crm_contact.get(\"first_name\") or existing_contact.first_name\n            existing_contact.last_name = crm_contact.get(\"last_name\") or existing_contact.last_name\n            existing_contact.company = crm_contact.get(\"company\") or existing_contact.company\n            existing_contact.title = crm_contact.get(\"title\") or existing_contact.title\n            existing_contact.phone = crm_contact.get(\"phone\") or existing_contact.phone\n            existing_contact.linkedin_url = crm_contact.get(\"linkedin_url\") or existing_contact.linkedin_url\n            \n            # Merge enrichment data\n            if crm_contact.get(\"enrichment_data\"):\n                existing_contact.enrichment_data.update(crm_contact[\"enrichment_data\"])\n            \n            existing_contact.last_synced_at = datetime.utcnow()\n            self.db.commit()",
    "apollo_import": "import asyncio\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nimport redis.asyncio as redis\nfrom sqlalchemy.orm import Session\n\nfrom app.models.crm import CRMContact, CRMSyncLog\nfrom app.services.crm.apollo import ApolloCRM\nfrom app.services.circuit_breaker import CircuitBreaker\nfrom app.services.retry_handler import retry_with_exponential_backoff\n\nclass {{ PlatformName }}SyncService:\n    \"\"\"{{ platform }} CRM sync service (import only).\"\"\"\n    \n    def __init__(self, db: Session, redis_client: redis.Redis):\n        self.db = db\n        self.redis_client = redis_client\n        self.crm = ApolloCRM()\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=5,\n            recovery_timeout=60,\n            expected_exception=Exception\n        )\n    \n    @retry_with_exponential_backoff(max_retries=3, base_delay=2.0)\n    async def enrich_contacts(\n        self,\n        emails: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"Enrich contacts using {{ platform }} data.\"\"\"\n        sync_log = CRMSyncLog(\n            platform=\"{{ platform }}\",\n            operation=\"enrich_contacts\",\n            started_at=datetime.utcnow(),\n            status=\"running\"\n        )\n        self.db.add(sync_log)\n        self.db.commit()\n        \n        try:\n            contacts_processed = 0\n            contacts_enriched = 0\n            \n            for email in emails:\n                contacts_processed += 1\n                \n                # Get enrichment data from Apollo\n                enrichment_data = await self.circuit_breaker.call(\n                    self.crm.enrich_contact,\n                    email\n                )\n                \n                if enrichment_data:\n                    # Find or create contact\n                    contact = self.db.query(CRMContact).filter(\n                        CRMContact.email == email\n                    ).first()\n                    \n                    if not contact:\n                        contact = CRMContact(\n                            crm_platform=\"{{ platform }}\",\n                            email=email,\n                            enrichment_data={}\n                        )\n                        self.db.add(contact)\n                    \n                    # Update with enrichment data\n                    contact.enrichment_data.update(enrichment_data)\n                    contact.last_synced_at = datetime.utcnow()\n                    contacts_enriched += 1\n            \n            self.db.commit()\n            \n            # Update sync log\n            sync_log.status = \"completed\"\n            sync_log.completed_at = datetime.utcnow()\n            sync_log.duration_seconds = (sync_log.completed_at - sync_log.started_at).total_seconds()\n            sync_log.contacts_processed = contacts_processed\n            sync_log.contacts_updated = contacts_enriched\n            \n            self.db.commit()\n            \n            return {\n                \"status\": \"success\",\n                \"platform\": \"{{ platform }}\",\n                \"contacts_processed\": contacts_processed,\n                \"contacts_enriched\": contacts_enriched,\n                \"duration_seconds\": sync_log.duration_seconds\n            }\n            \n        except Exception as e:\n            sync_log.status = \"failed\"\n            sync_log.error_message = str(e)\n            sync_log.completed_at = datetime.utcnow()\n            self.db.commit()\n            \n            raise",
    "linkedin_import": "import asyncio\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nimport redis.asyncio as redis\nfrom sqlalchemy.orm import Session\n\nfrom app.models.crm import CRMContact, CRMSyncLog\nfrom app.services.crm.linkedin import LinkedInCRM\nfrom app.services.circuit_breaker import CircuitBreaker\nfrom app.services.retry_handler import retry_with_exponential_backoff\n\nclass {{ PlatformName }}SyncService:\n    \"\"\"{{ platform }} CRM sync service (import only).\"\"\"\n    \n    def __init__(self, db: Session, redis_client: redis.Redis):\n        self.db = db\n        self.redis_client = redis_client\n        self.crm = LinkedInCRM()\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=5,\n            recovery_timeout=60,\n            expected_exception=Exception\n        )\n    \n    @retry_with_exponential_backoff(max_retries=3, base_delay=2.0)\n    async def import_profiles(\n        self,\n        profile_urls: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"Import LinkedIn profiles.\"\"\"\n        sync_log = CRMSyncLog(\n            platform=\"{{ platform }}\",\n            operation=\"import_profiles\",\n            started_at=datetime.utcnow(),\n            status=\"running\"\n        )\n        self.db.add(sync_log)\n        self.db.commit()\n        \n        try:\n            profiles_processed = 0\n            profiles_imported = 0\n            \n            for profile_url in profile_urls:\n                profiles_processed += 1\n                \n                # Scrape LinkedIn profile\n                profile_data = await self.circuit_breaker.call(\n                    self.crm.scrape_profile,\n                    profile_url\n                )\n                \n                if profile_data:\n                    # Find or create contact\n                    contact = self.db.query(CRMContact).filter(\n                        CRMContact.linkedin_url == profile_url\n                    ).first()\n                    \n                    if not contact:\n                        contact = CRMContact(\n                            crm_platform=\"{{ platform }}\",\n                            linkedin_url=profile_url,\n                            enrichment_data={}\n                        )\n                        self.db.add(contact)\n                    \n                    # Update with profile data\n                    contact.first_name = profile_data.get(\"first_name\") or contact.first_name\n                    contact.last_name = profile_data.get(\"last_name\") or contact.last_name\n                    contact.title = profile_data.get(\"title\") or contact.title\n                    contact.company = profile_data.get(\"company\") or contact.company\n                    contact.enrichment_data.update(profile_data.get(\"additional_data\", {}))\n                    contact.last_synced_at = datetime.utcnow()\n                    profiles_imported += 1\n            \n            self.db.commit()\n            \n            # Update sync log\n            sync_log.status = \"completed\"\n            sync_log.completed_at = datetime.utcnow()\n            sync_log.duration_seconds = (sync_log.completed_at - sync_log.started_at).total_seconds()\n            sync_log.contacts_processed = profiles_processed\n            sync_log.contacts_created = profiles_imported\n            \n            self.db.commit()\n            \n            return {\n                \"status\": \"success\",\n                \"platform\": \"{{ platform }}\",\n                \"profiles_processed\": profiles_processed,\n                \"profiles_imported\": profiles_imported,\n                \"duration_seconds\": sync_log.duration_seconds\n            }\n            \n        except Exception as e:\n            sync_log.status = \"failed\"\n            sync_log.error_message = str(e)\n            sync_log.completed_at = datetime.utcnow()\n            self.db.commit()\n            \n            raise"
  },
  "related_skills": [
    "database_migration",
    "write_tests"
  ],
  "examples": [
    {
      "scenario": "Close CRM bidirectional sync",
      "pattern": "close_crm_bidirectional",
      "parameters": {
        "platform": "close",
        "PlatformName": "Close"
      },
      "files_created": ["backend/app/services/crm/close_sync.py"],
      "test_command": "pytest tests/test_close_sync.py"
    },
    {
      "scenario": "Apollo.io enrichment import",
      "pattern": "apollo_import",
      "parameters": {
        "platform": "apollo",
        "PlatformName": "Apollo"
      },
      "files_created": ["backend/app/services/crm/apollo_sync.py"],
      "test_command": "pytest tests/test_apollo_sync.py"
    }
  ]
}